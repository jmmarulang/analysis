Lemma hoelder f g r s : measurable_fun setT f -> measurable_fun setT g ->
  (0 < r)%R -> (0 < s)%R -> (r^-1 + s^-1 = 1)%R ->
'Ne_1[(f \* g)] <= 'Ne_r%:E[f] * 'Ne_s%:E[g].
Proof.
move=>? ? ? ? ?;have [f0|f0] := eqVneq 'Ne_r%:E[f] 0; first by exact: hoelder0.
have [g0|g0] := eqVneq 'Ne_s%:E[g] 0. 
  rewrite muleC; apply: le_trans; last first. 
    apply: hoelder0 => //; first by rewrite addrC.
    by under eq_Lnorme do rewrite /= muleC.
have fpos : 0 < 'Ne_r%:E[f] by rewrite lt0e f0 Lnorme_ge0.
have gpos : 0 < 'Ne_s%:E[g] by rewrite lt0e g0 Lnorme_ge0.
have [foo|foo] := eqVneq 'Ne_r%:E[f] +oo; first by rewrite foo gt0_mulye ?leey.
have [goo|goo] := eqVneq 'Ne_s%:E[g] +oo; first by rewrite goo gt0_muley ?leey.
pose F := normalized r%:E f; pose G := normalized s%:E g.
rewrite [leLHS](_:_= 'Ne_1[(F \* G)] * 'Ne_r%:E[f] * 'Ne_s%:E[g]);last first.
  rewrite !Lnorme1; under [in RHS]eq_integral.
    move=> x _; rewrite /F /G /normalized/=.
    rewrite gee0_abs; last by rewrite !mule_ge0 ?abse_ge0 ?poweR_ge0 //.
    rewrite muleACA -abseM; over.
  rewrite ge0_integralZr//; last 3 first.
    - apply: measurableT_comp => //; exact: emeasurable_funM.
    - by move => ? _; rewrite abse_ge0.
    - by rewrite mule_ge0 ?poweR_ge0 //.
  rewrite -muleA -muleA [X in _ * X](_ : _ = 1) ?mule1// muleACA.
    move: fpos gpos foo goo; case: ('Ne_ r%:E [f]); 
      case: ('Ne_ s%:E [g]) => // a b + + _ _. 
    rewrite !lte_fin !poweR_EFin -EFinM=> bpos apos;f_equal.
    rewrite !powR_inv1; try by rewrite ?le0r ?bpos ?apos orbC.
    by rewrite !mulVf ?mul1r ?gt_eqF.
  rewrite -(mul1e ('Ne_r%:E[f] * _)) -muleA lee_pmul ?mule_ge0 ?Lnorme_ge0//.
  rewrite [leRHS](_ : _ = 
    \int[mu]_x ((F x `^ r%:E)*(r^-1%:E)  + (G x `^ s%:E)*(s^-1%:E) )).
    rewrite Lnorme1 ae_ge0_le_integral //.
    - by move => x _; rewrite abse_ge0.
    - apply: measurableT_comp => //.
      apply: emeasurable_funM=> //; exact: measurable_normalized.
    - move=> x _; rewrite // /F /G /normalized.
      have := le_lt_trans leNy0 fpos; have := le_lt_trans leNy0 gpos.
      move: foo goo fpos gpos; case If : ('Ne_ r%:E [f]); 
        case Ig : ('Ne_ s%:E [g]) => // foo goo fpos gpos _ _.
        + by rewrite ?adde_ge0 ?mule_ge0 ?poweR_ge0 ?ltW ?lte_fin ?invr_gt0.
        + apply /emeasurable_funD; apply /emeasurable_funM => //;
          apply /measurableT_comp_poweR; exact: measurable_normalized.
        + apply /aeW => x _; rewrite gee0_abs; 
            last by rewrite mule_ge0 // normalized_ge0.
          by rewrite conjugate_poweR// normalized_ge0. 
rewrite ge0_integralD//; last 4 first.
- by move=> x _;rewrite mule_ge0 ?poweR_ge0 ?lee_fin ?invr_ge0 ?ltW.
1,3: apply /emeasurable_funM => //;
  by apply /measurableT_comp_poweR /measurable_normalized.
- by move=> x _; rewrite mule_ge0 ?poweR_ge0 ?ltW ?lte_fin ?invr_gt0.
rewrite !ge0_integralZr//; last 3 first.
all: try by apply /measurableT_comp_poweR; exact: measurable_normalized.
all: try by move=> x _; rewrite poweR_ge0.
all: try by rewrite lee_fin invr_ge0 ltW.
repeat (rewrite integral_normalized//; last exact:integrable_poweR).
by rewrite !mul1e -EFinD;f_equal; apply esym.
Qed.

Lemma hoelder (f g : T -> R) p q :
    measurable_fun [set: T] f -> measurable_fun [set: T] g ->
    (0 < p)%R -> (0 < q)%R -> (p^-1 + q^-1 = 1)%R ->
 'N_1[(f \* g)%R] <= 'N_p%:E[f] * 'N_q%:E[g].
Proof.
move=> mf mg p0 q0 pq.
have [f0|f0] := eqVneq 'N_p%:E[f] 0%E; first exact: hoelder0.
have [g0|g0] := eqVneq 'N_q%:E[g] 0%E.
  rewrite muleC; apply: le_trans; last by apply: hoelder0 => //; rewrite addrC.
  by under eq_Lnorm do rewrite /= mulrC.
have {f0}fpos : 0 < 'N_p%:E[f] by rewrite lt0e f0 Lnormr_ge0.
have {g0}gpos : 0 < 'N_q%:E[g] by rewrite lt0e g0 Lnormr_ge0.
have [foo|foo] := eqVneq 'N_p%:E[f] +oo%E; first by rewrite foo gt0_mulye ?leey.
have [goo|goo] := eqVneq 'N_q%:E[g] +oo%E; first by rewrite goo gt0_muley ?leey.
pose F := normalized p f; pose G := normalized q g.
rewrite [leLHS](_ : _ = 'N_1[(F \* G)%R] * 'N_p%:E[f] * 'N_q%:E[g]); last first.
  rewrite !Lnorm1; under [in RHS]eq_integral.
    move=> x _; rewrite /F /G /normalized/=.
    rewrite ger0_norm; last by rewrite mulr_ge0 ?divr_ge0 ?fine_ge0 ?Lnormr_ge0.
    by rewrite mulrACA -normrM EFinM; over.
  rewrite ge0_integralZr//; last 2 first.
    - by do 2 apply: measurableT_comp => //; exact: measurable_funM.
    - by rewrite lee_fin mulr_ge0// invr_ge0 fine_ge0// Lnormr_ge0.
  rewrite -!muleA [X in _ * X](_ : _ = 1) ?mule1// EFinM muleACA.
  rewrite (_ : _ * 'N_p%:E[f] = 1) ?mul1e; last first.
    rewrite -[X in _ * X]fineK; last by rewrite ge0_fin_numE ?ltey// Lnormr_ge0.
    by rewrite -EFinM mulVr ?unitfE ?gt_eqF// fine_gt0// fpos/= ltey.
  rewrite -[X in _ * X]fineK; last by rewrite ge0_fin_numE ?ltey// Lnormr_ge0.
  by rewrite -EFinM mulVr ?unitfE ?gt_eqF// fine_gt0// gpos/= ltey.
rewrite -(mul1e ('N_p%:E[f] * _)) -muleA lee_pmul ?mule_ge0 ?Lnormr_ge0//.
rewrite [leRHS](_ : _ = \int[mu]_x (F x `^ p / p + G x `^ q / q)%:E).
  rewrite Lnorm1 ae_ge0_le_integral //.
  - do 2 apply: measurableT_comp => //.
    by apply: measurable_funM => //; exact: measurable_normalized.
  - by move=> x _; rewrite lee_fin addr_ge0// divr_ge0// ?powR_ge0// ltW.
  - by apply: measurableT_comp => //; apply: measurable_funD => //;
       apply: measurable_funM => //; apply: measurableT_comp_poweR => //;
       exact: measurable_normalized.
  apply/aeW => x _; rewrite lee_fin ger0_norm ?conjugate_powR ?normalized_ge0//.
  by rewrite mulr_ge0// normalized_ge0.
under eq_integral do rewrite EFinD.
rewrite ge0_integralD//; last 4 first.
- by move=> x _; rewrite lee_fin mulr_ge0// ?invr_ge0 ?powR_ge0// ltW.
- apply: measurableT_comp => //; apply: measurable_funM => //.
  by apply: measurableT_comp_poweR => //; exact: measurable_normalized.
- by move=> x _; rewrite lee_fin mulr_ge0// ?invr_ge0 ?powR_ge0// ltW.
- apply: measurableT_comp => //; apply: measurable_funM => //.
  by apply: measurableT_comp_poweR => //; exact: measurable_normalized.
under eq_integral do rewrite EFinM.
rewrite [X in X + _]ge0_integralZr//; last 3 first.
- apply: measurableT_comp => //.
  by apply: measurableT_comp_poweR => //; exact: measurable_normalized.
- by move=> x _; rewrite lee_fin powR_ge0.
- by rewrite lee_fin invr_ge0 ltW.
under [X in _ + X]eq_integral => x _ do rewrite EFinM.
rewrite ge0_integralZr//; last 3 first.
- apply: measurableT_comp => //.
  by apply: measurableT_comp_poweR => //; exact: measurable_normalized.
- by move=> x _; rewrite lee_fin powR_ge0.
- by rewrite lee_fin invr_ge0 ltW.
rewrite integral_normalized//; last exact: integrable_powR.
rewrite integral_normalized//; last exact: integrable_powR.
by rewrite 2!mul1e -EFinD pq.
Qed.

End hoelder.